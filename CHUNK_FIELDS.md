# Описание полей чанка

## Обзор

Каждый чанк содержит три варианта текста для разных целей:

1. **`normalized_text`** - для отображения результатов без дублирования
2. **`full_text`** - полный контекст чанка для справки
3. **`embedding_text`** - для создания векторных представлений

## Детальное описание полей

### Идентификация

- **`chunk_id`** (string)
  - Формат: `EDU:{page_id}:{first_core_block}-{last_core_block}`
  - Пример: `EDU:12345:5-10`
  - Формируется по СОБСТВЕННЫМ блокам чанка (без перекрытия)

- **`page_id`** (string) - ID страницы в Confluence

- **`space_key`** (string) - Ключ пространства Confluence

### Блоки и индексы

- **`block_indices`** (array of integers)
  - ВСЕ индексы блоков чанка: перекрытие + собственные блоки
  - Пример: `[3, 4, 5, 6, 7]` если overlap=[3,4], core=[5,6,7]

- **`core_block_indices`** (array of integers)
  - **ВАЖНО**: Индексы ТОЛЬКО собственных блоков чанка (БЕЗ перекрытия)
  - Используется для формирования `normalized_text`
  - Пример: `[5, 6, 7]`

- **`overlap_prev_block_indices`** (array of integers)
  - Индексы блоков, которые являются перекрытием из предыдущего чанка
  - Добавляются в НАЧАЛО чанка
  - Пример: `[3, 4]`
  - Пустой массив `[]` если перекрытия нет или это первый чанк

- **`overlap_next_block_indices`** (array of integers)
  - Индексы блоков, которые являются перекрытием из следующего чанка
  - Добавляются в КОНЕЦ чанка
  - Пример: `[11, 12]`
  - Пустой массив `[]` если перекрытия нет или это последний чанк

### Текстовое содержимое

#### `normalized_text` (string) ⭐ ОСНОВНОЙ ДЛЯ ОТОБРАЖЕНИЯ

**Назначение**: Отображение в результатах поиска без дублирования контента

**Содержит**:
- ✅ ТОЛЬКО собственные блоки чанка (из `core_block_indices`)
- ❌ БЕЗ перекрытия из предыдущего чанка
- ❌ БЕЗ перекрытия из следующего чанка
- ❌ БЕЗ тегов [PAGE], [SECTION], [TEXT]

**Пример**:
```
"Медицинские исследования показывают эффективность нового препарата. Клинические испытания завершены успешно."
```

**Использование**: Когда нужно объединить несколько чанков в результатах поиска:
```python
results = search("препарат")
# Чанк 1: normalized_text = "текст A"
# Чанк 2: normalized_text = "текст B"  (overlap из чанка 1 и в чанк 3 УЖЕ исключены)
# Объединенный результат: "текст A текст B" - без дублирования!
```

#### `full_text` (string)

**Назначение**: Полный контекст чанка для справки

**Содержит**:
- ✅ Перекрытие из предыдущего чанка (в начале)
- ✅ Собственные блоки чанка
- ✅ Перекрытие из следующего чанка (в конце)
- ❌ БЕЗ тегов [PAGE], [SECTION], [TEXT]

**Пример**:
```
"Лечение проводилось в течение 3 месяцев. Медицинские исследования показывают эффективность нового препарата. Клинические испытания завершены успешно. Побочные эффекты минимальны."
```
где "Лечение..." - из предыдущего чанка, "Побочные..." - из следующего

**Использование**: Когда нужен полный контекст одного чанка с учетом перекрытий для лучшего понимания.

#### `embedding_text` (string) ⭐ ОСНОВНОЙ ДЛЯ ЭМБЕДДИНГА

**Назначение**: Создание векторного представления чанка

**Содержит**:
- ✅ Тег [PAGE] с названием страницы (если `INCLUDE_PAGE_TAG=true`)
- ✅ Тег [SECTION] с иерархией заголовков (если `INCLUDE_SECTION_TAG=true`)
- ✅ Тег [TEXT] (если используются другие теги)
- ✅ Перекрытие из предыдущего чанка в начале (если `CHUNK_OVERLAP > 0`)
- ✅ Собственные блоки чанка
- ✅ Перекрытие из следующего чанка в конце (если `CHUNK_OVERLAP > 0`)

**Пример**:
```
[PAGE] Клинические исследования препарата X
[SECTION] Результаты > Эффективность
[TEXT] Лечение проводилось в течение 3 месяцев. Медицинские исследования показывают эффективность нового препарата. Клинические испытания завершены успешно. Побочные эффекты минимальны.
```

**Использование**: Передается в модель bge-m3 для создания эмбеддинга. Двусторонний overlap обеспечивает лучший контекст и связность между чанками.

### Иерархия заголовков

- **`full_heading_hierarchy`** (array of strings)
  - Полная иерархия заголовков для чанка (без обрезки)
  - Пример: `["Основы медицины", "Кардиология", "Диагностика", "ЭКГ"]`

- **`text_heading_hierarchy`** (array of strings)
  - Усеченная иерархия (учитывает `MAX_HEADING_LEVELS`)
  - Берутся последние N уровней (ближайшие к чанку)
  - Пример с `MAX_HEADING_LEVELS=2`: `["Диагностика", "ЭКГ"]`

- **`nearest_heading_id`** (string | null)
  - ID блока ближайшего заголовка
  - Формат: `EDU:{page_id}-{block_index}`

### Метаданные страницы

- **`page_title`** (string) - Название страницы
- **`page_version`** (integer) - Номер версии страницы
- **`last_modified`** (string) - Время последнего изменения в ISO формате

### Навигация

Объект **`navigation`** содержит информацию для перехода к чанку на странице:

- **`xpath_start`** (string)
  - XPath до первого СОБСТВЕННОГО блока чанка
  - Пример: `/html/body/div/section/p[3]`

- **`css_selector_start`** (string)
  - CSS селектор первого собственного блока
  - Пример: `div.content > section > p`

- **`text_offset_start`** (integer)
  - Смещение в символах от начала страницы до первого собственного блока
  - Используется для точного позиционирования

- **`text_length`** (integer)
  - Длина `normalized_text` в символах

- **`url`** (string)
  - URL с Text Fragment для подсветки текста
  - Формат: `{page_url}#:~:text={encoded_fragment}`
  - Пример: `https://confluence.../page#:~:text=Медицинские%20исследования`
  - При переходе браузер автоматически подсветит текст

- **`highlight_metadata`** (object)
  - Дополнительные данные для поиска фрагмента на странице:
    - `text_fragment` - первые 100 символов `normalized_text`
    - `block_type` - тип первого блока (p, div, li и т.д.)
    - `text_offset` - смещение текста

## Практические примеры

### Пример 1: Отображение результатов поиска

```python
results = search_engine.search("эффективность препарата")

for result in results[:5]:
    chunk = result['chunk']
    
    # Для отображения используем normalized_text
    print(f"Найдено в: {chunk['page_title']}")
    print(f"Раздел: {' > '.join(chunk['text_heading_hierarchy'])}")
    print(f"Текст: {chunk['normalized_text']}")  # БЕЗ дублирования!
    print(f"Перейти: {chunk['navigation']['url']}")
    print()
```

### Пример 2: Объединение нескольких чанков

```python
# Получили несколько последовательных чанков из одной страницы
chunks = [chunk1, chunk2, chunk3]

# Объединяем БЕЗ дублирования используя normalized_text
combined_text = ' '.join(chunk['normalized_text'] for chunk in chunks)

# Если бы использовали full_text - получили бы дубли в местах перекрытия!
```

### Пример 3: Создание эмбеддинга

```python
from transformers import AutoModel, AutoTokenizer

model = AutoModel.from_pretrained("BAAI/bge-m3")
tokenizer = AutoTokenizer.from_pretrained("BAAI/bge-m3")

# Для эмбеддинга используем embedding_text
chunk_embedding = model.encode(chunk['embedding_text'])

# Этот текст содержит:
# - Контекст страницы ([PAGE])
# - Контекст раздела ([SECTION])
# - Перекрытие для связи с соседними чанками
# - Основной контент
```

### Пример 4: Анализ перекрытий

```python
# Проверяем есть ли перекрытие
if chunk['overlap_prev_block_indices']:
    print(f"Чанк содержит {len(chunk['overlap_prev_block_indices'])} блоков перекрытия")
    print(f"Собственных блоков: {len(chunk['core_block_indices'])}")
else:
    print("Это первый чанк или перекрытие отключено")

# Расчет "чистой" длины контента
core_only_length = chunk['text_length']  # это длина normalized_text
full_with_overlap_length = len(chunk['full_text'])
overlap_size = full_with_overlap_length - core_only_length
print(f"Перекрытие добавило {overlap_size} символов контекста")
```

## Визуализация структуры чанков

```
Страница: [блок0][блок1][блок2][блок3][блок4][блок5][блок6][блок7][блок8][блок9]
                                                                              
Чанк 1:   [блок0][блок1][блок2][блок3]
          └──────────────────────────┘└────────┘
          core_block_indices: [0,1,2,3]  overlap_next: [4]
          overlap_prev: []
          normalized_text: "текст0 текст1 текст2 текст3"
          full_text: "текст0 текст1 текст2 текст3 текст4"  ← +блок4 в конце
          
Чанк 2:          [блок3][блок4][блок5][блок6][блок7]
                 └─────┘└──────────────────────┘└─────┘
                 overlap  core: [4,5,6]    overlap_next: [7]
          overlap_prev: [3]
          overlap_next: [7]
          normalized_text: "текст4 текст5 текст6"  ← БЕЗ блоков 3 и 7!
          full_text: "текст3 текст4 текст5 текст6 текст7"  ← С блоками 3 и 7

Чанк 3:                      [блок6][блок7][блок8][блок9]
                             └─────┘└──────────────────────┘
                             overlap  core: [7,8,9]
          overlap_prev: [6]
          overlap_next: []  (последний чанк)
          normalized_text: "текст7 текст8 текст9"  ← БЕЗ блока 6!
          full_text: "текст6 текст7 текст8 текст9"  ← С блоком 6
```

**Ключевые моменты**:
- Чанк 1: имеет overlap_next из чанка 2
- Чанк 2: имеет overlap_prev из чанка 1 И overlap_next из чанка 3
- Чанк 3: имеет только overlap_prev из чанка 2 (последний чанк)
- `normalized_text` всегда содержит ТОЛЬКО собственные блоки
- `full_text` содержит overlap с ОБЕИХ сторон (если есть)

## Важные моменты

1. **`normalized_text` НЕ содержит дубликатов** - это ключевое свойство для объединения результатов

2. **`embedding_text` СОДЕРЖИТ перекрытия с ОБЕИХ сторон** - это важно для качества эмбеддингов и связности контекста

3. **`full_text` СОДЕРЖИТ перекрытия с ОБЕИХ сторон** - полный контекст чанка

4. **`core_block_indices` отличается от `block_indices`**:
   - `block_indices` = overlap_prev + core + overlap_next (все блоки чанка)
   - `core_block_indices` = только собственные блоки

5. **Перекрытие берется из СОБСТВЕННЫХ блоков соседних чанков** - не создается цепочка дублирования

6. **Navigation ссылается на первый СОБСТВЕННЫЙ блок** - минуя перекрытие

7. **Двусторонний overlap**:
   - `overlap_prev` - последние блоки предыдущего чанка добавляются в НАЧАЛО
   - `overlap_next` - первые блоки следующего чанка добавляются в КОНЕЦ
   - Оба overlap входят в `full_text` и `embedding_text`
   - Ни один не входит в `normalized_text`
